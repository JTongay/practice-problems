export function HelloTest() {
  return true;
}

/**
 * This is a function to a convert any roman numeral string into a number
 * @param roman Roman numeral string ex: IV, X, etc.
 */
export function romanNumerals(roman: string): number {
  const table: Record<string, number> = {
    M: 1000,
    D: 500,
    C: 100,
    L: 50,
    X: 10,
    V: 5,
    I: 1
  };

  return roman.split('').reduceRight((prev, cur, i, arr) => {
    return table[arr[i + 1]] > table[cur]
      ? prev - table[cur]
      : prev + table[cur];
  }, 0);
}

/**
ATM machines allow 4 or 6 digit PIN codes and PIN codes cannot contain anything but exactly 4 digits or exactly 6 digits.

If the function is passed a valid PIN string, return true, else return false.
 */
export class PinValidator {
  public static validate(pin: string): boolean {
    const reg = new RegExp('^[0-9]+$');
    return reg.test(pin) && (pin.length === 4 || pin.length === 6);
  }
}

/**
If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.

Finish the solution so that it returns the sum of all the multiples of 3 or 5 below the number passed in.

Note: If the number is a multiple of both 3 and 5, only count it once.
 */
export class Multiples {
  public static threeOrFive(num: number): number {
    let total: number = 0;
    for (let i = 0; i < num; i++) {
      if (i % 3 === 0 || i % 5 === 0) {
        total += i;
      }
    }
    return total;
  }
}

/*
 * TwoSum
 * Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.

  You may assume that each input would have exactly one solution, and you may not use the same element twice.

  You can return the answer in any order.

  Input: nums = [2,7,11,15], target = 9
  Output: [0,1]
  Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].
 * */

export function twoSum(nums: number[], target: number): number[] {
  const tmp = new Map();

  for (let index = 0; index < nums.length; index++) {
    if (tmp.has(target - nums[index])) {
      return [tmp.get(target - nums[index]), index]
    }
    tmp.set(nums[index], index);
  }
  return [-1, -1];
};

/*
 * isPalindrome
 *
 * Returns a boolean if a given number is a palindrome, meaning the number is the same reversed
 * */

export function isPalindrome(x: number): boolean {
  return parseInt(x.toString().split("").reverse().join(""))  === x 
}

/*
 * findTheDifference
 *
 * you are given two strings, s and t
 *
 * string t is generated by random shuffling string s and then add one more letter to a random position
 *
 * return the letter that was added to t
 *
 * example:
 * Input: s = "abcd", t = "abcde"
 * Output: "e"
 * "e" was the letter that was added
 * */

export function findTheDifference(s: string, t: string): string {
  const beginning = s.split("");
  const random = t.split("");
  const combined = beginning.concat(random);

  return combined.filter((value, index) => combined.indexOf(value) !== index).join(""); 
}
